大家好，欢迎来到周一git专题。



## git clone



在上一篇文章当中我们聊了怎么在github当中创建一个属于自己的项目（repository），简称repo。除了建立自己的repo之外，我们更多的情况是拷贝别人的repo，这样才可以获得别人整理好的代码资料什么的，也更符合开源（白嫖）精神嘛。



这也不是什么秘密，相信很多人都知道，当我们想要获取其他人的repo的时候，可以通过git clone命令进行拉取。比如你想要获取我们这个教程的repo，可以通过下面这个命令。



```bash
git clone git@github.com:moutsea/git-tutorial.git
```



这个命令是哪里来的呢？简单介绍一下，这是在github当中找到的。我们点击Code那个绿色按钮，在下方的弹框里点击一下，就可以复制下来。一般情况下我们默认使用SSH协议，如果你看过我们上篇文章的话，你一定知道我在说什么。当然你也可以用HTTPS。



![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gihchovyoqj30x00kewhe.jpg)



还有一个问题是我们clone下来的这个repo它存在哪里呢？答案也很简单，就是我们在哪里运行的命令它就存在哪里。这个答案是写给小白用户的，所以如果你是小白，别忘了给我点赞哈。



另外再说一个小技巧，我们这样clone下来之后会在我们本地新建一个文件夹，然后把这个repo当中的内容存在里面。这个文件夹的名字默认是这个repo的名字，如果你不喜欢这个名字，也可以在命令当中进行设置，设置的方法也很简单，就是在命令最后加上一个你想要起的名字。



比如这样，你得到的文件夹就是TechFlow。

```bash
git clone git@github.com:moutsea/git-tutorial.git techflow
```



## git 四大状态



即使是git新手应该也都知道git三板斧，也就是常说的git add，git commit和git push。但是当我们使用这些命令的时候，有没有想过我们为什么要用这些命令呢？它们究竟代表了什么含义，这么做的意义是什么，如果我们不这么干又会发生什么？



如果我只是简单地告诉你git add就是添加，git commit就是提交，那么其实一点用也没有，和没说一样。因为关于git底层的运行机制一点也没提，我们也不知道为什么要添加，要提交，提交了添加了意味着什么。所以要解释清楚git这三板斧的原理，需要我们做一些更细致地解释，至少需要把git内部的四个状态讲清楚。



在我们进行这一段之前，首先和大家明确一个概念，就是git系统和我们计算机当中的系统其实是两码事。虽然git有很多神奇的操作，可以自由地回滚或者是创建文件，但它们依然是两套系统。git并不会自发地感知文件系统当中文件的变更，除非我们执行相关的命令。可以理解为它是被动响应的，毕竟git只是我们安装的一个软件，并不是操作系统的一部分。



这一点看似是废话，但是是很重要的基础，如果没搞明白，后面会产生很多疑惑。



我们继续来说git内部的状态，这四个状态分别是untrack，modified，committed和staged。之所以用英文，是为了大家以后阅读其他文档不会产生歧义。如果翻译了，之后大家去看其他人的博客可能看不明白。下面来简单介绍一下这几个状态分别意味着什么。



#### untrack



首先是untrack，untrack我们直译就可以了。track有轨道以及记录的意思，所以untrack就是还没记录。那么什么样的东西是还没记录的呢？比如可以想到新生儿，刚出生的新生儿名字都没有，当然也没有记录在案，所以需要登记一下人口。那么在登记之前，就可以认为这些新生儿是untrack的。



迁移到开发当中来，我们新创建的文件其实就是系统里的“新生儿”。在我们将它们记录在案之前，它们的状态就是untrack。所以当你在一个git项目当中新建了文件的时候，如果你用git status命令去查看git当中的状态，就会看到系统会提示你有些文件状态是untrack。



![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gihdhbjsu1j319e0aeaeb.jpg)



这里的展示是乱码，是因为我用的中文。这一串乱码就是“第三篇”的意思。我们可以注意到，在输出的结果最后一行，系统提示我们可以用git add命令来track它。这个也是git很人性化的一点，很多时候它会提醒我们可以使用什么命令做成什么样的事情。所以大家千万不要忽视这些日志，里面的信息是很重要的。



#### modified



下一个说的状态是modified，modified顾名思义就是修改过的意思。针对的就是已经登记在案的文件最近又发生了改动的情况，也就是说我们最近改过了某一个之前已经登记在案的文件，那么当我们查看状态的时候得到的就是modified，表示改动了，之前的记录已经不是最新的了，我们需要更新。



同样，我们可以通过git status命名来查看modified的情况。



![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gihdo28desj31bg0f6dm0.jpg)



我们看最下方的红字，它说的是“第三篇”这个文件我们已经有了新的改动，可以使用git add命令来将它更新，或者是使用git restore命令来取消这个文件的登记信息，也就是让他回到“新生儿”的状态。



#### staged



接下来介绍的状态是staged，它没有很好的翻译，可以大概理解成暂存。也就是说我们把所有的改动都记录下来了，现在git系统当中记录的已经是这个文件最新的状态了。



当我们创建了新的文件，或者是有了新的改动，执行git add之后，得到的状态就是staged。这个时候当我们执行git status，就会看到我们当下创建和更新了哪些文件。注意在所有的改动都暂存的情况下，git status是不会出现红色的提示的，只会有绿色的提示信息。



![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gihdt9d1nvj3182090wi4.jpg)



当然这里的文字之所以是绿色也是因为我配置了zsh这个终端，如果不配置应该也是没有的，就只能看到白色的的log。这个时候你就只能通过上面的文本来判断了，如果出现了Untracked files或者是Changes to be committed这些提示语的话，说明你还有改动没有同步到git当中来，可以通过git add命令完成。



#### committed



最后讲的一个状态就是committed，这个committed表示的已提交。前面说了staged只是暂存，还没有真正提交进git系统当中。只有通过命令git commit之后，才算是真正把暂存区的代码提交了。经过git commit命令之后，所有被提交的文件的状态就是committed。



