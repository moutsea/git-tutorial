大家好，今天的文章我们来介绍git当中一个非常常用的功能——**储藏**。



大家在协同开发的时候应该都有这样的经历，**有的时候我们的功能开发了一半，因为某些原因我们想要checkout到其他的分支上查看代码或者是执行某个工作**。但是如果我们直接执行checkout，git会禁止我们的行为。



我拿本地的项目举个例子，可以看到当我们执行了checkout命令之后，git提示我们在一些文件的改动会被覆盖，所以拒绝了我们的checkout命令。



![image-20201023084358700](https://tva1.sinaimg.cn/large/0081Kckwgy1gjyz52abioj31lk05qwfr.jpg)



这个时候应该怎么办呢？最好的办法当然是使用git commit把改动提交了。但问题是有的时候我们不想提交一些代码，比如还没有经过严谨的测试，或者是我们临时开发的一些测试功能等等。在这种情况下commit也是不合适的，即使提交了了，之后在push之前也会要把commit撤销了。但如果一不小心忘记了，可能就会造成悲剧。



针对这个问题，git提供了一个解决策略就是**stash**功能。



## 储藏改动



git stash可以将本地还没有提交的改动全部存储起来。接着，我们在之前的某一篇文章当中加上一行-test stash。



我们执行一下git diff，可以看到这行改动。



![](https://tva1.sinaimg.cn/large/0081Kckwgy1gjyzdlye03j31580gggn7.jpg)



接着我们执行git stash，会发现我们的git目录又回到了没有改动的状态。再执行git diff也看不到任何改动了。



![](https://tva1.sinaimg.cn/large/0081Kckwgy1gjyzeqa3q0j31iq04o40c.jpg)



这是因为git**把我们本地还没有提交的改动都暂存了起来**，这样方便我们进行checkout或者是其他一些操作，而不会起冲突或者是其他的影响。



## 应用改动



那么当我们操作完成之后，想要还原刚才暂存起来的内容，这个时候应该怎么办呢？



也有办法，我们只需要使用git stash apply或者是git stash pop这两个命令就可以将刚才暂存起来的内容还原了。但是这里有一个问题，就是stash apply和pop之间是不同的。



这里涉及到stash内部的实现机制，stash内部其实是通过堆栈实现的。pop对于堆栈而言很明确，就是弹出的意思。也就是说如果我们使用的是pop，那么当我们pop之后，**这条记录会在堆栈当中删除**。而如果使用的是apply呢，记录不会从堆栈当中删除，仍然会保留下来。



一般情况下我使用pop多一些，但是pop也有缺点，比如**pop没有办法选择应用的记录**。我们可以使用git stash list来查看一下当前堆栈当中已经有的记录。



![](https://tva1.sinaimg.cn/large/0081Kckwgy1gjz0fbsezdj30r804y74z.jpg)



如果我们使用git stash pop的话，默认的是应用的栈顶的记录，也就是stash@{0}。但如果我们使用stash apply的话，我们可以自由选择我们想要应用的记录。比如如果我们想要应用最后一条记录的话，我们可以这样：



```bash
git stash apply stash@{2}
```



关于应用储存的修改也有一些细节，首先是**储藏和修改对应的分支可以不同**。我们可以在一个分支储藏，之后切换到另外一个分支进行应用。并且如果我们在应用之前修改了同样的内容的话，也会引起合并冲突。



另外就是当我们应用储藏的时候，会发现我们之前add过的文件又重新回到了未暂存的状态。如果我们想要重新回到文件被暂存的状态时，我们可以使用index选项来执行。



```bash
git stash apply --index
```



对于我们已经不想要的储藏记录，我们可以执行git stash drop来进行删除。



## 其他技巧



除了上述的功能之外，git stash还有一些其他的用法。



比如--keep-index选项，在不加这个选项的时候，当我们使用git stash，它会把**所有没有commit的内容全部stash**。但是有的时候我们不希望这样，我们希望它只暂存我们没有add到暂存区的内容。这个时候我们就可以通过这个参数实现。



另外一个参数是-u或者是--include-untracked，我们从这个名字上也看得出来。它们的意思是在stash的时候将新创建并且还没有被git管理的文件也一并储藏起来。



除此之外，还有--patch的功能也很常用。patch我们曾经在上篇文章讲解交互式命令的时候讲到过，它可以将git针对的改动缩小到代码而不是文件级别。**交互式地和我们操作**哪些代码层面的改动需要存储起来，操作方法和上篇文章介绍的一样。大家如果有所遗忘可以在文末找到上一篇的文章进行回顾。



![](https://tva1.sinaimg.cn/large/0081Kckwgy1gjz0qus122j31r60kegq2.jpg)



最后一个功能是从储藏上新建一个分支，有的时候我们先储存了代码之后又继续进行了一些工作。这个时候如果我们再恢复从前的改动则会引起冲突。这个时候我们可以运行git stash branch新建一个新的分支，在这个分支上应用我们的提交。



```bash
git stash branch applystash
```



应用成功之后Git会自动抛弃掉对应的stash记录，非常方便，不过我个人没有用过，因为实际工作当中没有遇到这么复杂的情况。



今天的文章就到这里，衷心祝愿大家每天都有所收获。如果还喜欢今天的内容的话，请来一个**三连支持**吧~（**点赞、在看、转发**）